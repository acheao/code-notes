文件与网络的I/O处理一般比较耗时，可以考虑使用多线程
~~~java
class Something{
    void method(this){
        ...
    }
}
class Something{
    static void method(Something.class){
        ...
    }
}
~~~
判断是否获得线程
~~~java
assert Thread.holdsLock(obj);
//sleep是类的静态方法，所以睡眠的是当前调用的线程，而不是t的线程
t.sleeo(1000);
Thread.sleep(1000);
~~~
long和double变量不是原子性的，Java内存模型要求lock、unlock、read、load、use、assign、store、write这8个操作都具有原子性。而long和double是64位二进制，写的时候是两次write，所以不具备原子。java规范如此，但是实际JVM实现可能是原子性的。
Semaphone计数信号量
不可改变类
java.lang.String
java.math.BigInteger
java.math.BigDecimal
java.lang.Interger包装类
集合与多线程
Collections.synchronizedList
java.util.concurrent.CopyOnWriteArrayList
多线程java.concurrent包
java.util.concurrent.Exchanger
java.util.BlockingQueue
java.util.ArrayBlockingQueue
java.util.LinkedBlockingQueue
java.util.PriorityBlockingQueue
java.util.SynchronousQueue
